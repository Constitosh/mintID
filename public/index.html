
<!DOCTYPE html><!-- Last Published: Tue Sep 09 2025 13:01:05 GMT+0000 (Coordinated Universal Time) --><html data-wf-domain="www.oldmoney.io" data-wf-page="68c0237e6808f42fff3f63e1" data-wf-site="615d5f36962d65ff61d1cf80"><head><meta charset="utf-8"/><title>Mint</title><meta content="Mint" property="og:title"/><meta content="Mint" property="twitter:title"/><meta content="width=device-width, initial-scale=1" name="viewport"/><link href="https://cdn.prod.website-files.com/615d5f36962d65ff61d1cf80/css/old-money.webflow.shared.c8152e10d.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com" rel="preconnect"/><link href="https://fonts.gstatic.com" rel="preconnect" crossorigin="anonymous"/><script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js" type="text/javascript"></script><script type="text/javascript">WebFont.load({  google: {    families: ["Great Vibes:400","Oswald:200,300,400,500,600,700","Changa One:400,400italic","Inconsolata:400,700","Droid Sans:400,700","Lato:100,100italic,300,300italic,400,400italic,700,700italic,900,900italic","Exo:100,100italic,200,200italic,300,300italic,400,400italic,500,500italic,600,600italic,700,700italic,800,800italic,900,900italic","Roboto Condensed:regular,italic,700","Calistoga:regular","Playfair Display:regular,700,900,italic","Bebas Neue:regular"]  }});</script><script type="text/javascript">!function(o,c){var n=c.documentElement,t=" w-mod-";n.className+=t+"js",("ontouchstart"in o||o.DocumentTouch&&c instanceof DocumentTouch)&&(n.className+=t+"touch")}(window,document);</script><link href="https://cdn.prod.website-files.com/615d5f36962d65ff61d1cf80/68355d80420372af07ccf65e_DN32.png" rel="shortcut icon" type="image/x-icon"/><link href="https://cdn.prod.website-files.com/615d5f36962d65ff61d1cf80/68355d69ecf145f425f9697d_DN256.png" rel="apple-touch-icon"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-210296404-1"></script><script type="text/javascript">window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'UA-210296404-1', {'anonymize_ip': false});</script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-HLEQFNFQVG"></script><script type="text/javascript">window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('set', 'developer_id.dZGVlNj', true);gtag('config', 'G-HLEQFNFQVG');</script><style>
body {
    /*-moz-osx-font-smoothing: grayscale;*/
    /*-webkit-font-smoothing: antialiased;*/
}
select, input, textarea { 
    /*-webkit-appearance: none;*/
}
</style>

<script src="https://d1sgzjmrtg2ill.cloudfront.net/lodash.min.js" type="text/javascript"></script>
<!-- /*! jQuery v1.11.1 | (c) 2005, 2014 jQuery Foundation, Inc. | jquery.org/license */ -->
<script src="https://d1sgzjmrtg2ill.cloudfront.net/jquery-latest.min.js" type="text/javascript"></script>
<!-- axios v0.24.0 / Oct 25, 2021 -->
<script src="https://d1sgzjmrtg2ill.cloudfront.net/axios.min.js" type="text/javascript"></script>

<!--custom script -->
<script src="https://d38emnx5lxpy85.cloudfront.net/global/custom.js" type="text/javascript"></script>

<!-- Development -->
<!-- <script src="https://d34ijl2qgo9yvf.cloudfront.net/global/head.js" type="text/javascript"></script> -->
<!-- Production -->
<script src="https://d38emnx5lxpy85.cloudfront.net/global/head.js" type="text/javascript"></script>
</head><body class="body-22"><div class="w-layout-hflex"><img src="https://cdn.prod.website-files.com/615d5f36962d65ff61d1cf80/68944c47ba04ea792ce4370d_ednafo-OM_logo.webp" loading="lazy" alt="" class="image-249"/><img src="https://cdn.prod.website-files.com/615d5f36962d65ff61d1cf80/68944c4b516e801fda516b6e_dept.urinal_logo_small.webp" loading="lazy" alt="" class="image-250"/></div><div class="div-block-357"><img src="https://cdn.prod.website-files.com/615d5f36962d65ff61d1cf80/68bbfdd10390e8039401adc1_Untitled-2.webp" loading="lazy" sizes="(max-width: 1919px) 100vw, 1471.974365234375px" srcset="https://cdn.prod.website-files.com/615d5f36962d65ff61d1cf80/68bbfdd10390e8039401adc1_Untitled-2-p-500.webp 500w, https://cdn.prod.website-files.com/615d5f36962d65ff61d1cf80/68bbfdd10390e8039401adc1_Untitled-2-p-800.webp 800w, https://cdn.prod.website-files.com/615d5f36962d65ff61d1cf80/68bbfdd10390e8039401adc1_Untitled-2-p-1080.webp 1080w, https://cdn.prod.website-files.com/615d5f36962d65ff61d1cf80/68bbfdd10390e8039401adc1_Untitled-2.webp 1472w" alt="" class="image-251"/></div><div class="w-embed w-script"><!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Mint 1 NFT â€” 10 â‚³</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; padding: 24px; max-width: 720px; margin: 0 auto; }
    button { padding: 10px 14px; border: 1px solid #ccc; border-radius: 8px; background: #f5f5f5; cursor: pointer; }
    code { background: #f2f2f2; padding: 2px 6px; border-radius: 4px; }
    .card { border: 1px solid #eee; padding: 16px; border-radius: 12px; margin-top: 16px; }
  </style>
</head>
<body>
  <h1>Mint 1 NFT â€” 10 â‚³</h1>
  <p>Connect your wallet, sign the intent, then send exactly <b>10 â‚³</b> to the mint address below. One mint per stake key.</p>

  <div class="card">
    <button id="connect">Connect Wallet</button>
    <span id="wname"></span>
  </div>

  <div class="card">
    <div><b>Mint Address</b>: <code id="mintAddr">loadingâ€¦</code></div>
    <div><b>Price</b>: <span id="price">loadingâ€¦</span></div>
  </div>

  <div class="card">
    <button id="sign">Sign Intent</button>
    <div id="sig"></div>
  </div>

  <script>
  const apiBase = location.origin.replace(/\/$/, '');

  async function loadInfo() {
    const r = await fetch(apiBase + '/api/info');
    const info = await r.json();
    document.getElementById('mintAddr').textContent = info.mint_address;
    document.getElementById('price').textContent = (Number(info.price_lovelace)/1_000_000) + ' â‚³';
  }
  loadInfo();

  let walletApi = null;
  let walletName = null;

  document.getElementById('connect').onclick = async () => {
    // prefer Eternl/Vespr if installed
    const providers = ['eternl','vespr','nami','gerowallet','flint'];
    for (const p of providers) {
      if (window.cardano && window.cardano[p]) {
        walletName = p;
        break;
      }
    }
    if (!walletName) { alert('No CIP-30 wallet found. Install Eternl or VESPR.'); return; }
    walletApi = await window.cardano[walletName].enable();
    document.getElementById('wname').textContent = 'Connected: ' + walletName;
  };

  document.getElementById('sign').onclick = async () => {
    if (!walletApi) { alert('Connect wallet first'); return; }
    const used = await walletApi.getUsedAddresses();
    if (!used.length) { alert('No used address in wallet'); return; }
    const addr = used[0];
    const payload = 'I intend to mint 1 NFT for 10 ADA on this site at ' + new Date().toISOString();
    const hex = Array.from(new TextEncoder().encode(payload)).map(b=>b.toString(16).padStart(2,'0')).join('');
    try {
      const signed = await walletApi.signData(addr, hex);
      document.getElementById('sig').textContent = 'Signed âœ”ï¸Ž';
      // optionally POST to backend for audit
      fetch(apiBase + '/api/intent', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ addr, signed, payload, wallet: walletName })});
    } catch (e) {
      alert('Sign failed: ' + e.message);
    }
  };
  </script>
</body>
</html></div><script src="https://d3e54v103j8qbb.cloudfront.net/js/jquery-3.5.1.min.dc5e7f18c8.js?site=615d5f36962d65ff61d1cf80" type="text/javascript" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script><script src="https://cdn.prod.website-files.com/615d5f36962d65ff61d1cf80/js/webflow.schunk.a6a60ac13672b1dc.js" type="text/javascript"></script><script src="https://cdn.prod.website-files.com/615d5f36962d65ff61d1cf80/js/webflow.schunk.a64a5e8223acad49.js" type="text/javascript"></script><script src="https://cdn.prod.website-files.com/615d5f36962d65ff61d1cf80/js/webflow.aa5c1c49.d584efb9dc9939b2.js" type="text/javascript"></script><!-- Development -->
<!-- <script src="https://d34ijl2qgo9yvf.cloudfront.net/global/footer.js" type="text/javascript"></script> -->
<!-- Production -->
<script src="https://d38emnx5lxpy85.cloudfront.net/global/footer.js" type="text/javascript"></script><!-- Sats-Connect (for Xverse/leather compat) -->
<script src="https://unpkg.com/@sats-connect/core@1.1.1/dist/sats-connect.umd.js"></script>

<script>
(() => {
  /* ============ Config ============ */
  const BACKEND_URL = "https://api.thefakerug.com/api/submit";

  /* ============ State & Utilities ============ */
  let currentStage = "stage1";
  const answers = [];
  const chosenDrinks = [];
  let hud; // assigned on init

  let btc = { address: null, signature: null, message: null, provider: null, signedOk: false };
  let submittedOnce = false;

  // Safe selector helpers (avoid CSS.escape)
  const qs  = (sel, root=document) => root.querySelector(sel);
  const qsa = (sel, root=document) => Array.from(root.querySelectorAll(sel));
  const byId = id => document.getElementById(id);

  // fix mobile 100vh units
  function setVHVar() {
    const vh = window.visualViewport ? window.visualViewport.height : window.innerHeight;
    document.documentElement.style.setProperty('--vh', (vh/100) + 'px');
  }

  function recordAnswer(question, answer) { answers.push({ question, answer, ts: Date.now() }); }

  /* HUD: allow duplicates */
  function addDrinkToHUD(imgEl){
    if (!hud) return;
    const clone = new Image();
    clone.src = imgEl.src;
    clone.alt = imgEl.getAttribute('data-drink') || imgEl.alt || imgEl.src;
    chosenDrinks.push({ key: clone.alt, src: clone.src, ts: Date.now() });
    hud.appendChild(clone);
  }

  function seedWobble(container){
    qsa('img[src$=".webp"]', container).forEach((el) => {
      const a1 = (Math.random()*1.6).toFixed(2);
      el.style.animationDelay = `${a1}s`;
    });
  }

  function submitEmail() {
    const input = qs('#om-flow #email-input');
    const answer = input?.value.trim();
    if (answer) { recordAnswer("Contact Info", answer); goToStage("stage5"); }
    else { alert("Please enter something."); }
  }
  window.submitEmail = submitEmail;

  function submitTenFields(nextStageId = "stage7") {
    const inputs = qsa('#om-flow #stage6 .pill-input');
    const values = inputs.map(el => el.value.trim());
    if (values.some(v => !v)) { alert("Please fill out all 10 fields."); return; }
    inputs.forEach((el, i) => {
      const label = el.getAttribute('data-label') || el.placeholder || `Field ${i+1}`;
      recordAnswer(label, el.value.trim());
    });
    goToStage(nextStageId);
  }
  window.submitTenFields = submitTenFields;

  /* ============ Stop ALL media outside the active stage ============ */
  function stopAllMedia(exceptRoot) {
    // HTML5 video
    qsa('#om-flow video').forEach(v => {
      if (exceptRoot && exceptRoot.contains(v)) return;
      try {
        v.pause();
        v.currentTime = 0;     // rewind
        v.muted = true;        // kill sound
        v.removeAttribute('controls');
      } catch {}
    });
    // Iframes (e.g., YouTube)
    qsa('#om-flow iframe').forEach(f => {
      if (exceptRoot && exceptRoot.contains(f)) return;
      try { const s = f.src; f.src = s; } catch {}
    });
  }

  /* ============ Video autoplay on stage + tap to unmute (generalized) ============ */
  function handleStageVideos(target) {
    const vids = qsa('video', target);
    vids.forEach(v => {
      // Always inline + muted to satisfy autoplay policies
      v.playsInline = true;
      v.muted = true;
      v.removeAttribute('controls');

      // Restart on entry
      try { v.currentTime = 0; } catch {}

      // Try to play when ready
      const tryPlay = () => {
        const p = v.play();
        if (p && typeof p.catch === 'function') {
          p.catch(() => v.setAttribute('controls', 'controls')); // fallback controls if autoplay blocked
        }
      };
      if (v.readyState >= 2) { tryPlay(); }
      else { v.addEventListener('canplay', tryPlay, { once: true }); try { v.load(); } catch {} }

      // One-time tap/click to unmute
      const unmuteOnce = () => {
        v.muted = false;
        v.volume = 1.0;
        v.play().catch(()=>{});
      };
      v.addEventListener('click', unmuteOnce, { once: true });
      v.addEventListener('touchstart', unmuteOnce, { once: true, passive: true });
    });
  }

  function init() {
    const root = qs('#om-flow');
    if (!root) return; // not on this page

    setVHVar();
    window.addEventListener('resize', setVHVar);

    hud = qs('#om-flow #hud-drinks');

    // Global [data-answer] click handler (exclude <button> so stage14 handles itself)
    qsa('#om-flow [data-answer]:not(button)').forEach(btn => {
      btn.addEventListener('click', () => {
        const answer = btn.getAttribute('data-answer') || '';
        const next = btn.getAttribute('data-next');
        const q = btn.closest('.stage')?.getAttribute('data-question') || '';
        recordAnswer(q, answer);
        if (btn.getAttribute('data-drink')) addDrinkToHUD(btn);
        if (next) goToStage(next);
      });
    });

    initMultiPick('stage8', 2, 'stage9', 'Choose Characters');
    initCurrencyStage('stage14');
    initBtcStage('stage15');
    goToStage(currentStage);
  }

  // Ensure init runs even if script loads after DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }

  /* ============ Drunk strength (1+ drinks; stronger with 2/3; never on stage 10) ============ */
  function applyDrunkStrength(target, stageNum, drinkCount) {
    const tStage = Math.min(1, Math.max(0, (stageNum - 4) / 9));
    const tDrinks = Math.min(1, Math.max(0, drinkCount / 3));
    const scale = 0.35 + 0.65 * tDrinks;

    const lerp = (a,b,t)=> a + (b-a)*t;
    const px  = v => v.toFixed(2) + 'px';
    const deg = v => v.toFixed(2) + 'deg';
    const sec = v => v.toFixed(2) + 's';

    const dx   = lerp(0.6, 4.2, tStage) * scale;
    const dy   = lerp(0.4, 3.0, tStage) * scale;
    const rot  = lerp(0.2, 2.0, tStage) * scale;
    const blur = lerp(0.3, 2.2, tStage) * scale;
    const dur  = lerp(3.6, 2.4, Math.min(1, tStage*1.2));
    const vig  = lerp(0.12, 0.42, tStage) * scale;
    const grain= lerp(0.15, 0.45, tStage) * scale;

    target.style.setProperty('--dx',   px(dx));
    target.style.setProperty('--dy',   px(dy));
    target.style.setProperty('--rot',  deg(rot));
    target.style.setProperty('--blur', px(blur));
    target.style.setProperty('--dur',  sec(dur));
    target.style.setProperty('--vig',  Math.min(0.55, vig).toFixed(2));
    target.style.setProperty('--grain',Math.min(0.55, grain).toFixed(2));
    target.classList.add('drunk');
  }

  /* ============ Router ============ */
  function goToStage(stageId) {
    // hide & reset all stages
    qsa('#om-flow .stage').forEach(el => {
      el.style.display = 'none';
      el.classList.remove('drunk');
      el.style.removeProperty('--dx'); el.style.removeProperty('--dy'); el.style.removeProperty('--rot');
      el.style.removeProperty('--blur'); el.style.removeProperty('--dur'); el.style.removeProperty('--vig'); el.style.removeProperty('--grain');
    });

    const target = qs('#om-flow #' + stageId);
    if (!target) { console.warn('Stage not found:', stageId); return; }

    // ðŸ”¹ Stop anything playing in other stages before showing the new one
    stopAllMedia(target);

    target.style.display = 'flex';
    currentStage = stageId;

    if (stageId === 'stage10') {
      const row = qs('.button-row', target);
      if (row) { row.style.display = 'none'; setTimeout(() => { row.style.display = 'flex'; }, 15000); }
    }

    const match = /^stage(\d+)/.exec(stageId);
    const num = match ? parseInt(match[1], 10) : NaN;

    const drinksCount = chosenDrinks.length;
    const shouldDrunk = (drinksCount >= 1 && !isNaN(num) && num >= 4 && num <= 13 && num !== 10);
    if (shouldDrunk) { applyDrunkStrength(target, num, drinksCount); seedWobble(target); }

    // Autoplay (and set up unmute) for any videos inside the new stage
    handleStageVideos(target);

    if (stageId === 'stage16' && !submittedOnce) {
      submittedOnce = true;
      if (btc.address)   recordAnswer('BTC Address', btc.address);
      if (btc.signature) recordAnswer('BTC Signature (hex/base64)', btc.signature);
      if (btc.message)   recordAnswer('BTC Signed Message', btc.message);
      sendAllAnswers().catch(err => console.error('Submit failed:', err));
    }
  }
  window.goToStage = goToStage;

  /* ============ Stage 8: pick exactly two ============ */
  function initMultiPick(stageId, maxPicks, nextStageId, saveAsQuestion) {
    const stage = qs('#om-flow #' + stageId);
    if (!stage) return console.warn('Stage not found for multipick:', stageId);

    const picks = new Set();
    const submitBtn = qs('#' + stageId + '-submit', stage);
    const counterEl = qs('#' + stageId + '-counter', stage);
    const imgs = qsa('img.pickable[data-answer]', stage);

    function updateSubmitUI() {
      if (counterEl) {
        counterEl.textContent = '';
        counterEl.style.display = 'none';
      }
    }

    imgs.forEach(img => {
      img.addEventListener('click', () => {
        const answer = img.getAttribute('data-answer');
        const isSelected = img.classList.contains('selected');
        if (isSelected) { img.classList.remove('selected'); picks.delete(answer); updateSubmitUI(); return; }
        if (picks.size >= maxPicks) { img.classList.add('bump'); setTimeout(() => img.classList.remove('bump'), 200); return; }
        img.classList.add('selected'); picks.add(answer); updateSubmitUI();
      });
    });

    if (submitBtn) {
      submitBtn.addEventListener('click', () => {
        if (picks.size !== maxPicks) { alert(`Please choose exactly ${maxPicks}.`); return; }
        const answerCombined = Array.from(picks).join(', ');
        const question = saveAsQuestion || stage.getAttribute('data-question') || 'Selection';
        recordAnswer(question, answerCombined);
        goToStage(nextStageId);
      });
    }
    updateSubmitUI();
  }

  /* ============ Stage 14 (currency) ============ */
  function initCurrencyStage(stageId){
    const stage = qs('#om-flow #' + stageId);
    if (!stage) return;
    const buttons = qsa('.pill-button', stage);
    const submit  = qs('#currency-submit', stage);
    let selected  = null;

    function updateSubmitUI() {
      const enabled = !!selected;
      if (submit) { submit.style.opacity = enabled ? '1' : '.5'; submit.style.cursor = enabled ? 'pointer' : 'not-allowed'; }
    }

    buttons.forEach(btn => {
      btn.addEventListener('click', () => {
        buttons.forEach(b => b.classList.remove('selected'));
        btn.classList.add('selected');
        selected = btn.getAttribute('data-answer');
        stage.dataset.selected = selected;
        updateSubmitUI();
      });
    });

    if (submit) {
      submit.addEventListener('click', () => {
        if (!stage.dataset.selected) { alert('Please choose one option.'); return; }
        const q = stage.getAttribute('data-question') || 'Currency';
        recordAnswer(q, stage.dataset.selected);
        const next = submit.getAttribute('data-next') || 'stage15';
        goToStage(next);
      });
    }
    updateSubmitUI();
  }

  /* ============ Stage 15 (BTC connect + sign) â€” UniSat / Leather / Xverse ============ */
  function getSatsRequestFn() {
    try {
      if (window.Wallet && typeof window.Wallet.request === 'function') return window.Wallet.request;
      if (window.satsConnect && typeof window.satsConnect.request === 'function') return window.satsConnect.request;
      if (window.BitcoinProvider && typeof window.BitcoinProvider.request === 'function') return window.BitcoinProvider.request;
    } catch {}
    return null;
  }
  function getUniLikeProvider() {
    return window.unisat || (window.bitkeep && window.bitkeep.unisat) || (window.okxwallet && window.okxwallet.unisat) || null;
  }
  function pickBtcAddress(addresses) {
    if (!Array.isArray(addresses)) return null;
    const p2tr   = addresses.find(a => (a.symbol === 'BTC' || !a.symbol) && (a.type === 'p2tr' || a.format === 'p2tr'));
    const p2wpkh = addresses.find(a => (a.symbol === 'BTC' || !a.symbol) && (a.type === 'p2wpkh' || a.format === 'p2wpkh'));
    return (p2tr || p2wpkh || addresses.find(a => (a.symbol === 'BTC' || !a.symbol)))?.address || null;
  }
  function deepFindAllStrings(o, acc = []) {
    if (o == null) return acc;
    if (typeof o === 'string') { acc.push(o); return acc; }
    if (Array.isArray(o)) { for (const v of o) deepFindAllStrings(v, acc); return acc; }
    if (typeof o === 'object') { for (const k in o) deepFindAllStrings(o[k], acc); }
    return acc;
  }
  function deepPickFirstTaprootString(o) {
    const strings = deepFindAllStrings(o);
    const taproot = strings.find(s => /^bc1p[02-9ac-hj-np-z]{20,}/i.test(s));
    if (taproot) return taproot;
    const anyBtc = strings.find(s => /^bc1[02-9ac-hj-np-z]{20,}/i.test(s) || /^[13][a-km-zA-HJ-NP-Z1-9]{20,}/.test(s));
    return anyBtc || null;
  }
  function pickTaprootFromSatsAccounts(accountsOrResponse) {
    const accounts = Array.isArray(accountsOrResponse)
      ? accountsOrResponse
      : (accountsOrResponse?.accounts || accountsOrResponse?.result?.accounts || []);
    if (!Array.isArray(accounts) || accounts.length === 0) return null;

    const norm = accounts.map(a => {
      const addressesArr = Array.isArray(a.addresses) ? a.addresses : [];
      const nestedAddrObj = (typeof a.address === 'object' && a.address) ? a.address : null;

      const flatCandidates = [
        a.address,
        nestedAddrObj?.address,
        nestedAddrObj?.btcAddress,
        a.btcAddress,
        a.ordinalsAddress
      ].filter(Boolean);

      const listCandidates = addressesArr.map(x => x?.address).filter(Boolean);
      const allCandidates = [...flatCandidates, ...listCandidates];

      const typeHints = [
        String(a.type || '').toLowerCase(),
        String(a.format || '').toLowerCase(),
        String(nestedAddrObj?.type || '').toLowerCase(),
        String(nestedAddrObj?.format || '').toLowerCase(),
        ...addressesArr.map(x => String(x?.type || x?.format || '').toLowerCase())
      ];

      const purposes = a.purposes
        ? (Array.isArray(a.purposes) ? a.purposes.map(p => String(p).toLowerCase()) : [String(a.purposes).toLowerCase()])
        : (a.purpose ? [String(a.purpose).toLowerCase()] : []);

      return { raw: a, allCandidates, typeHints, purposes };
    });

    const ordEntry = norm.find(n => n.purposes.includes('ordinals') || n.purposes.includes('ordinal'));
    if (ordEntry) {
      const tap = ordEntry.allCandidates.find(s => /^bc1p[02-9ac-hj-np-z]{20,}/i.test(s));
      if (tap) return tap;
    }
    for (const n of norm) {
      const tap = n.allCandidates.find(s => /^bc1p[02-9ac-hj-np-z]{20,}/i.test(s));
      if (tap) return tap;
    }
    const trEntry = norm.find(n => n.typeHints.some(h => h.includes('p2tr') || h.includes('tr')));
    if (trEntry) {
      const cand = trEntry.allCandidates.find(Boolean);
      if (cand) return cand;
    }
    const deepTap = deepPickFirstTaprootString(accounts);
    if (deepTap) return deepTap;
    for (const n of norm) {
      const any = n.allCandidates.find(Boolean);
      if (any) return any;
    }
    return null;
  }

  function initBtcStage(stageId) {
    const stage = qs('#om-flow #' + stageId);
    if (!stage) return;

    const elConnect  = qs('#btc-connect', stage);
    const elSign     = qs('#btc-sign', stage);
    const elStatus   = qs('#btc-status', stage);
    const elAddr     = qs('#btc-address', stage);
    const elSig      = qs('#btc-signature', stage);
    const elMsg      = qs('#btc-message', stage);
    const elContinue = qs('#stage15-continue', stage);

    function setStatus(t) { if (elStatus) elStatus.textContent = t; }
    function gateContinue(on) {
      if (!elContinue) return;
      elContinue.style.opacity = on ? '1' : '.5';
      elContinue.style.cursor  = on ? 'pointer' : 'not-allowed';
      elContinue.dataset.enabled = on ? '1' : '0';
    }
    elContinue?.addEventListener('click', (e) => {
      if (elContinue.dataset.enabled !== '1') {
        e.stopPropagation(); e.preventDefault();
        alert('Please connect and sign first.');
      }
    }, true);

    function snapshot() {
      return {
        unisat:  !!getUniLikeProvider(),
        leather: !!window.LeatherProvider,
        sats:    !!(window.satsConnect?.getAccounts || getSatsRequestFn())
      };
    }

    async function waitForProviders(msTotal = 5000, step = 250) {
      const tries = Math.max(1, Math.floor(msTotal / step));
      for (let i = 0; i < tries; i++) {
        const s = snapshot();
        if (s.unisat || s.leather || s.sats) return s;
        setStatus(`Looking for walletsâ€¦ (${i+1}/${tries})`);
        await new Promise(r => setTimeout(r, step));
      }
      return snapshot();
    }

    (async () => {
      const s = await waitForProviders();
      if (s.unisat) setStatus('UniSat-compatible wallet detected. Click Connect.');
      else if (s.leather) setStatus('Leather detected. Click Connect.');
      else if (s.sats) setStatus('Sats-Connect wallet detected (e.g., Xverse). Click Connect.');
      else setStatus('No wallet detected yet. You can still click Connect to retry.');
    })();

    elConnect?.addEventListener('click', async () => {
      try {
        const s = await waitForProviders(3500, 250);

        if (s.unisat) {
          const uni = getUniLikeProvider();
          let accs = [];
          try { accs = await uni.getAccounts(); } catch {}
          if (!accs || accs.length === 0) {
            try { accs = await uni.requestAccounts(); }
            catch (e) {
              if (e && (e.code === -32603 || e.code === 4001)) {
                setStatus(`UniSat connect: ${e.message || 'requestAccounts failed'} â€” retryingâ€¦`);
                await new Promise(r => setTimeout(r, 600));
                accs = await uni.requestAccounts();
              } else { throw e; }
            }
          }
          if (!accs || accs.length === 0) throw new Error('No address returned by UniSat-like provider');
          btc.address  = accs[0];
          btc.provider = 'unisat';
          setStatus(`Connected (UniSat): ${btc.address}`);
          if (elAddr) elAddr.value = btc.address;
          if (elSign) elSign.disabled = false;
          return;
        }

        if (s.leather) {
          const resp = await window.LeatherProvider.request("getAddresses");
          const address = pickBtcAddress(resp?.result?.addresses);
          if (!address) throw new Error('No BTC address returned by Leather');
          btc.address  = address;
          btc.provider = 'leather';
          setStatus(`Connected (Leather): ${btc.address}`);
          if (elAddr) elAddr.value = btc.address;
          if (elSign) elSign.disabled = false;
          return;
        }

        if (s.sats) {
          if (window.satsConnect?.getAccounts) {
            const res = await window.satsConnect.getAccounts({
              purposes: ['ordinals', 'payment'],
              message: 'Connect to ednafo',
              network: { type: 'Mainnet' }
            });
            let addr = pickTaprootFromSatsAccounts(res);
            if (!addr) addr = deepPickFirstTaprootString(res);
            if (!addr) throw new Error('No Taproot address found from Sats-Connect wallet');

            btc.address  = addr;
            btc.provider = 'xverse';
            setStatus(`Connected (Xverse/Sats): ${btc.address}`);
            if (elAddr) elAddr.value = btc.address;
            if (elSign) elSign.disabled = false;
            return;
          }

          const walletRequest = getSatsRequestFn();
          const resp = await walletRequest('getAccounts', {
            purposes: ['ordinals', 'payment'],
            message: 'Connect to ednafo',
            network: { type: 'Mainnet' }
          });
          let addr = pickTaprootFromSatsAccounts(resp);
          if (!addr) addr = deepPickFirstTaprootString(resp);
          if (!addr) throw new Error('No Taproot address found from Sats-Connect wallet');

          btc.address  = addr;
          btc.provider = 'xverse';
          setStatus(`Connected (Xverse/Sats): ${btc.address}`);
          if (elAddr) elAddr.value = btc.address;
          if (elSign) elSign.disabled = false;
          return;
        }

        alert('No supported Bitcoin wallet found. Install/enable UniSat, Leather, or Xverse, then reload.');
      } catch (err) {
        console.error(err);
        const code = (err && typeof err.code !== 'undefined') ? ` [code ${err.code}]` : '';
        setStatus(`Connect failed${code}: ${err.message || err}`);
      }
    });

    elSign?.addEventListener('click', async () => {
      try {
        if (!btc.address) { alert('Connect wallet first.'); return; }

        const message = `ednafo verification\n${new Date().toISOString()}\nnonce:${crypto.getRandomValues(new Uint32Array(1))[0]}`;
        let signature;

        if (btc.provider === 'unisat') {
          const uni = getUniLikeProvider();
          signature = await uni.signMessage(message);
        } else if (btc.provider === 'leather') {
          const resp = await window.LeatherProvider.request("signMessage", {
            message,
            paymentType: "p2tr",
            network: "mainnet"
          });
          signature = resp?.result?.signature;
          if (resp?.result?.address) {
            btc.address = resp.result.address;
            if (elAddr) elAddr.value = btc.address;
          }
        } else if (btc.provider === 'xverse') {
          if (window.satsConnect?.signMessage) {
            const out = await window.satsConnect.signMessage({
              address: btc.address,
              message,
              network: { type: 'Mainnet' }
            });
            signature = out?.signature;
          } else {
            const walletRequest = getSatsRequestFn();
            const out = await walletRequest('signMessage', {
              address: btc.address,
              message,
              network: { type: 'Mainnet' }
            });
            signature = out?.signature || out?.result?.signature;
          }
        } else {
          const walletRequest = getSatsRequestFn();
          if (walletRequest) {
            const out = await walletRequest('signMessage', {
              address: btc.address,
              message,
              network: { type: 'Mainnet' }
            });
            signature = out?.signature || out?.result?.signature;
          } else {
            alert('No signer available.');
            return;
          }
        }

        if (!signature) throw new Error('No signature returned');

        btc.signature = signature;
        btc.message   = message;
        btc.signedOk  = true;

        const sigEl = byId('btc-signature'); if (sigEl) sigEl.value = signature;
        const msgEl = byId('btc-message');   if (msgEl) msgEl.value = message;

        const elStatus = byId('btc-status');
        if (elStatus) elStatus.textContent = 'Message signed. âœ…';
        const elContinue = byId('stage15-continue');
        if (elContinue) { elContinue.style.opacity = '1'; elContinue.style.cursor = 'pointer'; elContinue.dataset.enabled = '1'; }

        if (!submittedOnce) {
          submittedOnce = true;
          if (btc.address)   recordAnswer('BTC Address', btc.address);
          if (btc.signature) recordAnswer('BTC Signature (hex/base64)', btc.signature);
          if (btc.message)   recordAnswer('BTC Signed Message', btc.message);

          try {
            await sendAllAnswers();
            if (elStatus) elStatus.textContent = 'Message signed. âœ… Saved to server.';
          } catch (err) {
            if (elStatus) elStatus.textContent = 'Signed but save failed: ' + (err?.message || err);
          }
        }
      } catch (err) {
        console.error(err);
        const elStatus = byId('btc-status');
        if (elStatus) elStatus.textContent = `Sign failed: ${err.message || err}`;
      }
    });

    // initial UI hints
    if (elSign) elSign.disabled = true;
    if (elStatus) elStatus.textContent = 'Looking for walletsâ€¦';
    if (elContinue) {
      elContinue.style.opacity = '.5';
      elContinue.style.cursor = 'not-allowed';
      elContinue.dataset.enabled = '0';
      elContinue.addEventListener('click', (e) => {
        if (elContinue.dataset.enabled !== '1') {
          e.stopPropagation(); e.preventDefault();
          alert('Please connect and sign first.');
        }
      }, true);
    }
  }

  /* ============ Final submit to backend ============ */
  async function sendAllAnswers() {
    const payload = {
      answers,
      btc: {
        address: btc.address || null,
        signature: btc.signature || null,
        message: btc.message || null,
        provider: btc.provider || null
      },
      userAgent: navigator.userAgent
    };
    const res = await fetch(BACKEND_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
      credentials: 'include'
    });
    if (!res.ok) {
      const t = await res.text().catch(()=> '');
      throw new Error(`Server ${res.status}: ${t}`);
    }
  }
})();
</script>
</body></html>
